<!DOCTYPE html><html lang="fr"><head><meta charset="UTF-8"/><meta name="og:site_name" content="CodingWithWolves"/><link rel="canonical" href="https://codingwithwolves.com/posts/2025-04-21-pourquoi-les-enums-sont-a-eviter"/><meta name="twitter:url" content="https://codingwithwolves.com/posts/2025-04-21-pourquoi-les-enums-sont-a-eviter"/><meta name="og:url" content="https://codingwithwolves.com/posts/2025-04-21-pourquoi-les-enums-sont-a-eviter"/><title>Pourquoi les enums sont à éviter | CodingWithWolves</title><meta name="twitter:title" content="Pourquoi les enums sont à éviter | CodingWithWolves"/><meta name="og:title" content="Pourquoi les enums sont à éviter | CodingWithWolves"/><meta name="description" content="Le blog de Yoan Smit où on parle pratique de code, de Swift et de la tech en général."/><meta name="twitter:description" content="Le blog de Yoan Smit où on parle pratique de code, de Swift et de la tech en général."/><meta name="og:description" content="Le blog de Yoan Smit où on parle pratique de code, de Swift et de la tech en général."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/stylesheets/code.css" type="text/css"/><link rel="stylesheet" href="/stylesheets/components.css" type="text/css"/><link rel="stylesheet" href="/stylesheets/resets.css" type="text/css"/><link rel="stylesheet" href="/stylesheets/elements.css" type="text/css"/><link rel="stylesheet" href="/stylesheets/modifiers.css" type="text/css"/><link rel="stylesheet" href="/assets/fontawesome/css/fontawesome.min.css" type="text/css"/><link rel="stylesheet" href="/assets/fontawesome/css/brands.min.css" type="text/css"/><link rel="stylesheet" href="/assets/fontawesome/css/solid.min.css" type="text/css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" type="text/css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="icon" href="/favicon.ico" sizes="any"/><link rel="apple-touch-icon" href="/favicon/apple-touch-icon.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to CodingWithWolves"/></head><body><nav class="site-header"><div class="site-header__container"><span class="site-header__anchor vertical-center"><a href="/" class="site-header__link">C2W</a></span><span class="site-header__navigation-item vertical-center"><a href="/about" class="site-header__link">YOAN SMIT</a></span></div><div class="site-header__avatar-container horizontal-center"><img src="/images/avatar.png" alt="Avatar de Coding with Wolves" class="site-header__avatar"/></div></nav><div class="page-content"><article role="main" class="post-details__container"><div><h1 class="post-details__title">Pourquoi les enums sont à éviter</h1><h2 class="post-details__subtitle">... et comment les remplacer</h2><span class="post-details__metadata">Posté le 21 avril 2025</span><span class="post-details__metadata"> · </span><span class="post-details__metadata">4 minutes</span></div><div><p>Je ne compte plus les projets sur lesquels j'ai travaillé qui utilisaient les <code>enums</code> à tort et à travers. Mais alors quels sont les best practices autour de leur utilisation ? Quand doit-on les utiliser et quand doit-on les éviter comme la peste ?</p><p>En voiture Simone, je vais te donner mon avis (après tout t'es là pour ça).</p><h2>Les enums, à éviter ?</h2><p>Dans certains cas, les <code>enum</code> sont parfaitement valables. Dans d'autres, c'est se tirer une balle dans le pied, le genou et la hanche.</p><p>Je parle par exemple de :</p><ul><li>La navigation</li><li>Les events de tracking</li><li>Les APIs</li></ul><p>Ce sont les cas les plus fréquents d'utilisation foireuse que j'ai vu et, comme j'ai vu très peu d'appli sans appel réseau ou tracking, autant te dire que ça se retrouve dans beaucoup de codebase.</p><p>Pourquoi ? Pour plein de raisons.</p><h4>Impossible d'ajouter des <code>case</code></h4><p>Plus précisément, il est impossible d'ajouter des <code>case</code> ailleurs que dans la définition de l'enum.</p><p>Et ça c'est chiant.</p><p>Pour des petites enums, c'est marginal mais si on reprend les exemples du dessus, il n'est pas rare que ça dépasse les dizaines voire centaines de lignes. C'est dans ces cas là qu'on aurait aimé pouvoir splitter l'enum en plusieurs fichiers. Sans parler de l'apport que cela aurait pour le namespacing, encapsulation et j'en passe.</p><h4>Ajouter des propriétés est une vraie corvée</h4><p>Très souvent dans les enums, on vient ajouter des propriétés dans lesquels on utilise un <code>switch/case</code> pour spécifier la bonne valeur.</p><p>À chaque ajout de propriété, on augmente donc la longueur du fichier par le nombre de <code>case</code>. Et ça peut aller très vite. Même si on aimerait ne l'ajouter que pour quelques cas spécifiques.</p><p>De la même manière, si on veut voir les valeurs de toutes les propriétés pour un cas donné, on est bons pour se farcir chaque <code>switch/case</code> de chaque propriété.</p><p>Bienvenue en enfer.</p><h4>Les principes SOLID en sueur</h4><p>Imagine qu'on a une enum bien grosse, tout plein de proprétés, le cas basique quoi, on est contents.</p><p>Maintenant imagine qu'on veut rajouter un nouveau cas, on est moins contents.</p><p>Parce qu'il va falloir le rajouter dans TOUTES les propriétés et donc dans tous les <code>switch/case</code>, sans compter les usages extérieurs.</p><p>Et ça, le "O" de SOLID, il aime pas des masses.</p><blockquote><p>Pour ceux qui sont fachés avec les principes SOLID, le "O" concerne le "Open/Closed principle". En gros, un objet doit pouvoir être étendu mais pas modifié. Concrètement, tu peux ajouter des propriétés, des méthodes et autres, à ton objet mais tout ça sans venir modifier l'existant.</p></blockquote><p>Or, ici, dans le cas où on veut ajouter un nouveau cas, on vient modifier l'enum de base, ainsi que chacune de ses propriétés.</p><p>Le risque c'est qu'on vienne péter quelque chose en faisant ces modifications.</p><h4>Mais alors on fait quoi ?</h4><p>Maintenant qu'on a craché sur les enums bien comme il faut, il s'agirait de trouver comment faire mieux. Et ça tombe bien parce que j'ai quelques idées.</p><h2>Protocol-oriented development</h2><p>C'est un peu la solution à tous nos problèmes mais encore une fois on va s'en sortir à coup de <code>protocol</code> (mais pas que, trop de suspense).</p><p>Prenons l'exemple du tracking et voyons en quoi ça nous aide.</p><p>Partons du principe qu'à la base on a cet enum :</p><pre><code><span class="keyword">enum</span> TrackingEvent {
  <span class="keyword">case</span> homeViewed
  <span class="keyword">case</span> homeButtonTapped
  ...
  
  <span class="keyword">var</span> name: <span class="type">String</span> {
    <span class="keyword">switch self</span> {
      <span class="keyword">case</span> .<span class="dotAccess">homeViewed</span>: <span class="string">"home-viewed"</span>
      <span class="keyword">case</span> .<span class="dotAccess">homeButtonTapped</span>: <span class="string">"home-button-tapped"</span>
    }
  }
  
  <span class="keyword">var</span> parameters: [<span class="type">String</span>: <span class="type">Any</span>] {
    ...
  }
}
</code></pre><p>Et ce tracker :</p><pre><code><span class="keyword">struct</span> Tracker {
  <span class="keyword">func</span> track(<span class="keyword">_</span> event: <span class="type">TrackingEvent</span>) {
    ...
  }
}
</code></pre><p>Si ça ressemble à ta codebase, félicitations, tu vas voir comment on peut faire (beaucoup) mieux.</p><p>La première chose à faire est de déclarer notre protocol :</p><pre><code><span class="keyword">protocol</span> TrackingEvent {
  <span class="keyword">var</span> name: <span class="type">String</span> { <span class="keyword">get</span> }
  <span class="keyword">var</span> parameters: [<span class="type">String</span>: <span class="type">Any</span>] { <span class="keyword">get</span> }
}
</code></pre><p>Rien de sorcier, c'est plus ou moins une copie de l'enum.</p><p>Et c'est là que la magie opère, pour définir nos events de tracking, on a juste à implémenter ce protocol :</p><pre><code><span class="keyword">struct</span> HomeViewedTrackingEvent: <span class="type">TrackingEvent</span> {
  <span class="keyword">let</span> name: <span class="type">String</span> = <span class="string">"home-viewed"</span>
  <span class="keyword">let</span> parameters: [<span class="type">String</span>: <span class="type">Any</span>]
}
</code></pre><p>Et c'est tout.</p><p>On vient de régler notre premier problème, plus d'enum de centaines de lignes. on peut enfin ajouter les events comme on veut, dans différents fichiers, dans différents packages, où on veut, sky is the limit comme disent les ricains.</p><p>Plus de souci non plus pour SOLID puisque chaque event vit indépendemment les uns des autres.</p><p>Le seul problème qu'il nous reste est l'ajout de propriété, qui est un peu plus touchy. Ajouter une propriété au protocole implique de repasser sur tous les objets qui l'implémente. Ou bien on peut passer par un autre protocol :</p><pre><code><span class="keyword">protocol</span> LabeledTrackingEvent: <span class="type">TrackingEvent</span> {
    <span class="keyword">var</span> label: <span class="type">String</span> { <span class="keyword">get</span> }
}
</code></pre><p>En modifiant l'event, ça donne :</p><pre><code><span class="keyword">struct</span> HomeViewedTrackingEvent: <span class="type">LabeledTrackingEvent</span> {
  <span class="keyword">let</span> name: <span class="type">String</span> = <span class="string">"home-viewed"</span>
  <span class="keyword">let</span> label: <span class="type">String</span> = <span class="string">"home-viewed-label"</span>
  <span class="keyword">let</span> parameters: [<span class="type">String</span>: <span class="type">Any</span>]
}
</code></pre><p>On pourrait se dire qu'à travers cette approche on perd la "dot-syntax" si pratique de l'enum. Mais non. Pour cela on peut passer par des extensions du protocol :</p><pre><code><span class="keyword">extension</span> <span class="type">TrackingEvent</span> <span class="keyword">where</span> <span class="type">Self</span> == <span class="type">HomeViewedTrackingEvent</span> {
    <span class="keyword">static func</span> homeView(param: [<span class="type">String</span>: <span class="type">Any</span>]) -&gt; <span class="type">Self</span> {
        <span class="type">HomeViewedTrackingEvent</span>(parameters: param)
    }
}
</code></pre><p>Ce qui donnerait comme call-site :</p><pre><code>tracker.<span class="call">track</span>(.<span class="call">homeView</span>(param: params))
</code></pre><p>Nice !</p><p>L'avantage de cette solution est qu'elle permet d'avoir différents initializer, stored properties et autres puisque chaque implémentation vit sa propre vie. On a la polyvalence du protocol tout en ayant la simplicité d'utilisation de l'enum.</p><p>L'inconvénient c'est que c'est un poil verbeux.</p><h2>Struct et variables statiques</h2><p>L'alternative est d'utiliser directement une struct.</p><p>Prenons par exemple le cas des fonts si tu es en train d'implémenter un design system.</p><pre><code><span class="keyword">struct</span> TextStyle {
  <span class="keyword">let</span> font: <span class="type">Font</span>
  <span class="keyword">let</span> lineHeight: <span class="type">CGFloat</span>
  <span class="keyword">let</span> letterSpacing: <span class="type">CGFloat</span>
}
</code></pre><p>Cette fois on va passer par des variables statiques pour définir les différentes options :</p><pre><code><span class="keyword">extension</span> <span class="type">TextStyle</span> {
  <span class="keyword">static let</span> body = <span class="type">TextStyle</span>(font: .<span class="dotAccess">system</span>, lineHeight: <span class="number">12</span>, letterSpacing: <span class="number">4</span>)
}
</code></pre><p>On pourra ensuite l'utiliser de cette façon :</p><pre><code><span class="type">Text</span>(<span class="string">"Hello world"</span>)
  .<span class="call">style</span>(.<span class="dotAccess">body</span>)
</code></pre><p>L'avantage principal par rapport à l'approche avec protocol est que c'est moins verbeux.</p><p>Seul souci : impossible de rajouter des stored properties ou des initializers pour chaque "implémentation".</p><p>C'est pour cela que je priviligies cette approche dans les cas les plus simples simples où je n'aurai pas besoin d'avoir d'init custom, avec peu de propriétés.</p><hr><p>Comme souvent, il n'y a pas qu'une seule solution à un problème. Le vrai problème est de trouver la bonne solution.</p><p>Ce ne sont ici que des exemples que j'utilise au quotidien mais ce ne sont pas les seuls alternatives aux <code>enums</code>.</p><p>N'hésite pas à consulter la codebase Swift, elle regorge d'exemple. Après tout c'est open-source alors autant ne pas se priver.</p><p>Si tu as des questions ou des remarques n'hésite pas à me contacter sur <a href="https://www.linkedin.com/in/yoan-smit/">LinkedIn</a>, je me ferai un plaisir de te répondre.</p><p>Cheers.</p></div><div class="post-details__footer"><a href="/posts/2023-02-22-l-importance-du-naming" class="post-details__footer__next">ARTICLE PRÉCÉDENT →</a></div></article></div><footer><div class="footer__container"><ul><li><a href="/feed.xml" title="RSS" target="_blank"><span aria-hidden="true" class="rounded background-gray link-container"><i class="fa fa-rss fa-inverse"></i></span></a></li><li><a href="https://github.com/Naxyoh" title="GitHub" target="_blank"><span aria-hidden="true" class="rounded background-gray link-container"><i class="fab fa-github fa-inverse"></i></span></a></li><li><a href="https://linkedin.com/in/yoan-smit" title="LinkedIn" target="_blank"><span aria-hidden="true" class="rounded background-gray link-container"><i class="fab fa-linkedin fa-inverse"></i></span></a></li></ul><span class="footer__copyright footer-text">Yoan Smit &nbsp;•&nbsp; © 2022 &nbsp;•&nbsp; <a href="/" class="footer-link">CodingWithWolves.com</a></span><p class="footer__license footer-text">Fait avec amour grâce à <a href="https://github.com/johnsundell/publish" target="_blank" class="footer-link">Publish</a></p><p class="footer__license footer-text">Ce blog est couvert selon les termes de la <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank" class="footer-link">Licence Creative Commons Attribution 4.0 International</a></p></div></footer></body></html>